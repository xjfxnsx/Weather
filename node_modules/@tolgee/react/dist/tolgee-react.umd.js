(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('react'), require('@tolgee/web')) :
    typeof define === 'function' && define.amd ? define(['exports', 'react', '@tolgee/web'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global["@tolgee/react"] = {}, global.React, global["@tolgee/web"]));
})(this, (function (exports, React, web) { 'use strict';

    function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

    var React__default = /*#__PURE__*/_interopDefaultLegacy(React);

    function getTolgeeWithDeactivatedWrapper(tolgee) {
        return Object.assign(Object.assign({}, tolgee), { t(...args) {
                // @ts-ignore
                const props = web.getTranslateProps(...args);
                return tolgee.t(Object.assign(Object.assign({}, props), { noWrap: true }));
            } });
    }
    /**
     * Updates tolgee static data and language, to be ready right away for the first render
     * and therefore compatible with SSR.
     *
     * It also ensures that the first render is done without wrapping and so it avoids
     * "client different than server" issues.
     * *
     * @param tolgeeInstance initialized Tolgee instance
     * @param language language that is obtained outside of Tolgee on the server and client
     * @param staticData static data for the language
     * @param enabled if set to false, no action is taken
     */
    function useTolgeeSSR(tolgeeInstance, language, staticData, enabled = true) {
        const [noWrappingTolgee] = React.useState(() => getTolgeeWithDeactivatedWrapper(tolgeeInstance));
        const [initialRender, setInitialRender] = React.useState(enabled);
        React.useEffect(() => {
            setInitialRender(false);
        }, []);
        React.useMemo(() => {
            if (enabled) {
                // we have to prepare tolgee before rendering children
                // so translations are available right away
                // events emitting must be off, to not trigger re-render while rendering
                tolgeeInstance.setEmitterActive(false);
                tolgeeInstance.addStaticData(staticData);
                tolgeeInstance.changeLanguage(language);
                tolgeeInstance.setEmitterActive(true);
            }
        }, [language, staticData, tolgeeInstance]);
        React.useState(() => {
            // running this function only on first render
            if (!tolgeeInstance.isLoaded() && enabled) {
                // warning user, that static data provided are not sufficient
                // for proper SSR render
                const missingRecords = tolgeeInstance
                    .getRequiredRecords(language)
                    .map(({ namespace, language }) => namespace ? `${namespace}:${language}` : language)
                    .filter((key) => !(staticData === null || staticData === void 0 ? void 0 : staticData[key]));
                // eslint-disable-next-line no-console
                console.warn(`Tolgee: Missing records in "staticData" for proper SSR functionality: ${missingRecords.map((key) => `"${key}"`).join(', ')}`);
            }
        });
        return initialRender ? noWrappingTolgee : tolgeeInstance;
    }

    const DEFAULT_REACT_OPTIONS = {
        useSuspense: true,
    };
    let ProviderInstance;
    const getProviderInstance = () => {
        if (!ProviderInstance) {
            ProviderInstance = React__default["default"].createContext(undefined);
        }
        return ProviderInstance;
    };
    let LAST_TOLGEE_INSTANCE = undefined;
    const TolgeeProvider = ({ tolgee, options, children, fallback, ssr, }) => {
        // prevent restarting tolgee unnecesarly
        // however if the instance change on hot-reloading
        // we want to restart
        React.useEffect(() => {
            if ((LAST_TOLGEE_INSTANCE === null || LAST_TOLGEE_INSTANCE === void 0 ? void 0 : LAST_TOLGEE_INSTANCE.run) !== tolgee.run) {
                if (LAST_TOLGEE_INSTANCE) {
                    LAST_TOLGEE_INSTANCE.stop();
                }
                LAST_TOLGEE_INSTANCE = tolgee;
                tolgee
                    .run()
                    .catch((e) => {
                    // eslint-disable-next-line no-console
                    console.error(e);
                })
                    .finally(() => {
                    setLoading(false);
                });
            }
        }, [tolgee]);
        let tolgeeSSR = tolgee;
        const { language, staticData } = (typeof ssr !== 'object' ? {} : ssr);
        tolgeeSSR = useTolgeeSSR(tolgee, language, staticData, Boolean(ssr));
        const [loading, setLoading] = React.useState(!tolgeeSSR.isLoaded());
        const optionsWithDefault = Object.assign(Object.assign({}, DEFAULT_REACT_OPTIONS), options);
        const TolgeeProviderContext = getProviderInstance();
        if (optionsWithDefault.useSuspense) {
            return (React__default["default"].createElement(TolgeeProviderContext.Provider, { value: { tolgee: tolgeeSSR, options: optionsWithDefault } }, loading ? (fallback) : (React__default["default"].createElement(React.Suspense, { fallback: fallback || null }, children))));
        }
        return (React__default["default"].createElement(TolgeeProviderContext.Provider, { value: { tolgee: tolgeeSSR, options: optionsWithDefault } }, loading ? fallback : children));
    };

    let globalContext;
    const GlobalContextPlugin = (options) => (tolgee) => {
        globalContext = {
            tolgee,
            options: Object.assign(Object.assign({}, DEFAULT_REACT_OPTIONS), options),
        };
        return tolgee;
    };
    function getGlobalContext() {
        return globalContext;
    }

    const useTolgeeContext = () => {
        const TolgeeProviderContext = getProviderInstance();
        const context = React.useContext(TolgeeProviderContext) || getGlobalContext();
        if (!context) {
            throw new Error("Couldn't find tolgee instance, did you forgot to use `TolgeeProvider`?");
        }
        return context;
    };

    const useRerender = () => {
        const [instance, setCounter] = React.useState(0);
        const rerender = React.useCallback(() => {
            setCounter((num) => num + 1);
        }, [setCounter]);
        return { instance, rerender };
    };

    const useTranslateInternal = (ns, options) => {
        const { tolgee, options: defaultOptions } = useTolgeeContext();
        const namespaces = web.getFallback(ns);
        const namespacesJoined = web.getFallbackArray(namespaces).join(':');
        const currentOptions = Object.assign(Object.assign({}, defaultOptions), options);
        // dummy state to enable re-rendering
        const { rerender, instance } = useRerender();
        const subscriptionRef = React.useRef();
        const subscriptionQueue = React.useRef([]);
        subscriptionQueue.current = [];
        const subscribeToNs = (ns) => {
            var _a;
            subscriptionQueue.current.push(ns);
            (_a = subscriptionRef.current) === null || _a === void 0 ? void 0 : _a.subscribeNs(ns);
        };
        const isLoaded = tolgee.isLoaded(namespaces);
        React.useEffect(() => {
            const subscription = tolgee.onNsUpdate(rerender);
            subscriptionRef.current = subscription;
            subscription.subscribeNs(namespaces);
            subscriptionQueue.current.forEach((ns) => {
                subscription.subscribeNs(ns);
            });
            return () => {
                subscription.unsubscribe();
            };
        }, [namespacesJoined, tolgee]);
        React.useEffect(() => {
            tolgee.addActiveNs(namespaces);
            return () => tolgee.removeActiveNs(namespaces);
        }, [namespacesJoined, tolgee]);
        const t = React.useCallback((props) => {
            var _a;
            const fallbackNs = (_a = props.ns) !== null && _a !== void 0 ? _a : namespaces === null || namespaces === void 0 ? void 0 : namespaces[0];
            subscribeToNs(fallbackNs);
            return tolgee.t(Object.assign(Object.assign({}, props), { ns: fallbackNs }));
        }, [tolgee, instance]);
        if (currentOptions.useSuspense && !isLoaded) {
            throw tolgee.addActiveNs(namespaces, true);
        }
        return { t, isLoading: !isLoaded };
    };

    const useTranslate = (ns, options) => {
        const { t: tInternal, isLoading } = useTranslateInternal(ns, options);
        const t = React.useCallback((...params) => {
            // @ts-ignore
            const props = web.getTranslateProps(...params);
            return tInternal(props);
        }, [tInternal]);
        return { t, isLoading };
    };

    function unwrapSingleElementArray(value) {
        if (Array.isArray(value) && value.length === 1) {
            return value[0];
        }
        else {
            return value;
        }
    }
    const wrapTagHandlers = (params) => {
        if (!params) {
            return undefined;
        }
        const result = {};
        Object.entries(params || {}).forEach(([key, value]) => {
            if (typeof value === 'function') {
                result[key] = (chunk) => {
                    return value(addReactKeys(chunk));
                };
            }
            else if (React__default["default"].isValidElement(value)) {
                const el = value;
                result[key] = (chunk) => {
                    return el.props.children === undefined && (chunk === null || chunk === void 0 ? void 0 : chunk.length)
                        ? React__default["default"].cloneElement(el, {}, addReactKeys(chunk))
                        : React__default["default"].cloneElement(el);
                };
            }
            else {
                result[key] = value;
            }
        });
        return result;
    };
    const addReactKeys = (children) => {
        const val = unwrapSingleElementArray(children);
        if (Array.isArray(val)) {
            return val.map((item, i) => (React__default["default"].createElement(React__default["default"].Fragment, { key: i }, item)));
        }
        else {
            return val;
        }
    };

    const TBase = (props) => {
        const key = props.keyName || props.children;
        if (key === undefined) {
            // eslint-disable-next-line no-console
            console.error('T component: keyName not defined');
        }
        const defaultValue = props.defaultValue ||
            (props.keyName ? props.children : undefined);
        const translation = addReactKeys(props.t({
            key: key,
            params: wrapTagHandlers(props.params),
            defaultValue,
            noWrap: props.noWrap,
            ns: props.ns,
            language: props.language,
        }));
        return React__default["default"].createElement(React__default["default"].Fragment, null, translation);
    };

    const T = (props) => {
        const { t } = useTranslateInternal();
        return React__default["default"].createElement(TBase, Object.assign({ t: t }, props));
    };

    const useTolgee = (events) => {
        const { tolgee } = useTolgeeContext();
        const { rerender } = useRerender();
        React.useEffect(() => {
            const listeners = events === null || events === void 0 ? void 0 : events.map((e) => tolgee.on(e, rerender));
            return () => {
                listeners === null || listeners === void 0 ? void 0 : listeners.forEach((listener) => listener.unsubscribe());
            };
        }, [events === null || events === void 0 ? void 0 : events.join(':')]);
        return tolgee;
    };

    exports.GlobalContextPlugin = GlobalContextPlugin;
    exports.T = T;
    exports.TBase = TBase;
    exports.TolgeeProvider = TolgeeProvider;
    exports.getProviderInstance = getProviderInstance;
    exports.useTolgee = useTolgee;
    exports.useTolgeeSSR = useTolgeeSSR;
    exports.useTranslate = useTranslate;
    Object.keys(web).forEach(function (k) {
        if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
            enumerable: true,
            get: function () { return web[k]; }
        });
    });

    Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=tolgee-react.umd.js.map
