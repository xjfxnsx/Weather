import React, { useState, useEffect, useMemo, Suspense, useContext, useCallback, useRef } from 'react';
import { getTranslateProps, getFallback, getFallbackArray } from '@tolgee/web';
export * from '@tolgee/web';

function getTolgeeWithDeactivatedWrapper(tolgee) {
    return Object.assign(Object.assign({}, tolgee), { t(...args) {
            // @ts-ignore
            const props = getTranslateProps(...args);
            return tolgee.t(Object.assign(Object.assign({}, props), { noWrap: true }));
        } });
}
/**
 * Updates tolgee static data and language, to be ready right away for the first render
 * and therefore compatible with SSR.
 *
 * It also ensures that the first render is done without wrapping and so it avoids
 * "client different than server" issues.
 * *
 * @param tolgeeInstance initialized Tolgee instance
 * @param language language that is obtained outside of Tolgee on the server and client
 * @param staticData static data for the language
 * @param enabled if set to false, no action is taken
 */
function useTolgeeSSR(tolgeeInstance, language, staticData, enabled = true) {
    const [noWrappingTolgee] = useState(() => getTolgeeWithDeactivatedWrapper(tolgeeInstance));
    const [initialRender, setInitialRender] = useState(enabled);
    useEffect(() => {
        setInitialRender(false);
    }, []);
    useMemo(() => {
        if (enabled) {
            // we have to prepare tolgee before rendering children
            // so translations are available right away
            // events emitting must be off, to not trigger re-render while rendering
            tolgeeInstance.setEmitterActive(false);
            tolgeeInstance.addStaticData(staticData);
            tolgeeInstance.changeLanguage(language);
            tolgeeInstance.setEmitterActive(true);
        }
    }, [language, staticData, tolgeeInstance]);
    useState(() => {
        // running this function only on first render
        if (!tolgeeInstance.isLoaded() && enabled) {
            // warning user, that static data provided are not sufficient
            // for proper SSR render
            const missingRecords = tolgeeInstance
                .getRequiredRecords(language)
                .map(({ namespace, language }) => namespace ? `${namespace}:${language}` : language)
                .filter((key) => !(staticData === null || staticData === void 0 ? void 0 : staticData[key]));
            // eslint-disable-next-line no-console
            console.warn(`Tolgee: Missing records in "staticData" for proper SSR functionality: ${missingRecords.map((key) => `"${key}"`).join(', ')}`);
        }
    });
    return initialRender ? noWrappingTolgee : tolgeeInstance;
}

const DEFAULT_REACT_OPTIONS = {
    useSuspense: true,
};
let ProviderInstance;
const getProviderInstance = () => {
    if (!ProviderInstance) {
        ProviderInstance = React.createContext(undefined);
    }
    return ProviderInstance;
};
let LAST_TOLGEE_INSTANCE = undefined;
const TolgeeProvider = ({ tolgee, options, children, fallback, ssr, }) => {
    // prevent restarting tolgee unnecesarly
    // however if the instance change on hot-reloading
    // we want to restart
    useEffect(() => {
        if ((LAST_TOLGEE_INSTANCE === null || LAST_TOLGEE_INSTANCE === void 0 ? void 0 : LAST_TOLGEE_INSTANCE.run) !== tolgee.run) {
            if (LAST_TOLGEE_INSTANCE) {
                LAST_TOLGEE_INSTANCE.stop();
            }
            LAST_TOLGEE_INSTANCE = tolgee;
            tolgee
                .run()
                .catch((e) => {
                // eslint-disable-next-line no-console
                console.error(e);
            })
                .finally(() => {
                setLoading(false);
            });
        }
    }, [tolgee]);
    let tolgeeSSR = tolgee;
    const { language, staticData } = (typeof ssr !== 'object' ? {} : ssr);
    tolgeeSSR = useTolgeeSSR(tolgee, language, staticData, Boolean(ssr));
    const [loading, setLoading] = useState(!tolgeeSSR.isLoaded());
    const optionsWithDefault = Object.assign(Object.assign({}, DEFAULT_REACT_OPTIONS), options);
    const TolgeeProviderContext = getProviderInstance();
    if (optionsWithDefault.useSuspense) {
        return (React.createElement(TolgeeProviderContext.Provider, { value: { tolgee: tolgeeSSR, options: optionsWithDefault } }, loading ? (fallback) : (React.createElement(Suspense, { fallback: fallback || null }, children))));
    }
    return (React.createElement(TolgeeProviderContext.Provider, { value: { tolgee: tolgeeSSR, options: optionsWithDefault } }, loading ? fallback : children));
};

let globalContext;
const GlobalContextPlugin = (options) => (tolgee) => {
    globalContext = {
        tolgee,
        options: Object.assign(Object.assign({}, DEFAULT_REACT_OPTIONS), options),
    };
    return tolgee;
};
function getGlobalContext() {
    return globalContext;
}

const useTolgeeContext = () => {
    const TolgeeProviderContext = getProviderInstance();
    const context = useContext(TolgeeProviderContext) || getGlobalContext();
    if (!context) {
        throw new Error("Couldn't find tolgee instance, did you forgot to use `TolgeeProvider`?");
    }
    return context;
};

const useRerender = () => {
    const [instance, setCounter] = useState(0);
    const rerender = useCallback(() => {
        setCounter((num) => num + 1);
    }, [setCounter]);
    return { instance, rerender };
};

const useTranslateInternal = (ns, options) => {
    const { tolgee, options: defaultOptions } = useTolgeeContext();
    const namespaces = getFallback(ns);
    const namespacesJoined = getFallbackArray(namespaces).join(':');
    const currentOptions = Object.assign(Object.assign({}, defaultOptions), options);
    // dummy state to enable re-rendering
    const { rerender, instance } = useRerender();
    const subscriptionRef = useRef();
    const subscriptionQueue = useRef([]);
    subscriptionQueue.current = [];
    const subscribeToNs = (ns) => {
        var _a;
        subscriptionQueue.current.push(ns);
        (_a = subscriptionRef.current) === null || _a === void 0 ? void 0 : _a.subscribeNs(ns);
    };
    const isLoaded = tolgee.isLoaded(namespaces);
    useEffect(() => {
        const subscription = tolgee.onNsUpdate(rerender);
        subscriptionRef.current = subscription;
        subscription.subscribeNs(namespaces);
        subscriptionQueue.current.forEach((ns) => {
            subscription.subscribeNs(ns);
        });
        return () => {
            subscription.unsubscribe();
        };
    }, [namespacesJoined, tolgee]);
    useEffect(() => {
        tolgee.addActiveNs(namespaces);
        return () => tolgee.removeActiveNs(namespaces);
    }, [namespacesJoined, tolgee]);
    const t = useCallback((props) => {
        var _a;
        const fallbackNs = (_a = props.ns) !== null && _a !== void 0 ? _a : namespaces === null || namespaces === void 0 ? void 0 : namespaces[0];
        subscribeToNs(fallbackNs);
        return tolgee.t(Object.assign(Object.assign({}, props), { ns: fallbackNs }));
    }, [tolgee, instance]);
    if (currentOptions.useSuspense && !isLoaded) {
        throw tolgee.addActiveNs(namespaces, true);
    }
    return { t, isLoading: !isLoaded };
};

const useTranslate = (ns, options) => {
    const { t: tInternal, isLoading } = useTranslateInternal(ns, options);
    const t = useCallback((...params) => {
        // @ts-ignore
        const props = getTranslateProps(...params);
        return tInternal(props);
    }, [tInternal]);
    return { t, isLoading };
};

function unwrapSingleElementArray(value) {
    if (Array.isArray(value) && value.length === 1) {
        return value[0];
    }
    else {
        return value;
    }
}
const wrapTagHandlers = (params) => {
    if (!params) {
        return undefined;
    }
    const result = {};
    Object.entries(params || {}).forEach(([key, value]) => {
        if (typeof value === 'function') {
            result[key] = (chunk) => {
                return value(addReactKeys(chunk));
            };
        }
        else if (React.isValidElement(value)) {
            const el = value;
            result[key] = (chunk) => {
                return el.props.children === undefined && (chunk === null || chunk === void 0 ? void 0 : chunk.length)
                    ? React.cloneElement(el, {}, addReactKeys(chunk))
                    : React.cloneElement(el);
            };
        }
        else {
            result[key] = value;
        }
    });
    return result;
};
const addReactKeys = (children) => {
    const val = unwrapSingleElementArray(children);
    if (Array.isArray(val)) {
        return val.map((item, i) => (React.createElement(React.Fragment, { key: i }, item)));
    }
    else {
        return val;
    }
};

const TBase = (props) => {
    const key = props.keyName || props.children;
    if (key === undefined) {
        // eslint-disable-next-line no-console
        console.error('T component: keyName not defined');
    }
    const defaultValue = props.defaultValue ||
        (props.keyName ? props.children : undefined);
    const translation = addReactKeys(props.t({
        key: key,
        params: wrapTagHandlers(props.params),
        defaultValue,
        noWrap: props.noWrap,
        ns: props.ns,
        language: props.language,
    }));
    return React.createElement(React.Fragment, null, translation);
};

const T = (props) => {
    const { t } = useTranslateInternal();
    return React.createElement(TBase, Object.assign({ t: t }, props));
};

const useTolgee = (events) => {
    const { tolgee } = useTolgeeContext();
    const { rerender } = useRerender();
    useEffect(() => {
        const listeners = events === null || events === void 0 ? void 0 : events.map((e) => tolgee.on(e, rerender));
        return () => {
            listeners === null || listeners === void 0 ? void 0 : listeners.forEach((listener) => listener.unsubscribe());
        };
    }, [events === null || events === void 0 ? void 0 : events.join(':')]);
    return tolgee;
};

export { GlobalContextPlugin, T, TBase, TolgeeProvider, getProviderInstance, useTolgee, useTolgeeSSR, useTranslate };
//# sourceMappingURL=tolgee-react.esm.mjs.map
