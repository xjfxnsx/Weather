function isPromise(value) {
    return Boolean(value && typeof value.then === 'function');
}
function valueOrPromise(value, callback) {
    if (isPromise(value)) {
        return Promise.resolve(value).then(callback);
    }
    else {
        return callback(value);
    }
}
function handleRegularOrAsyncErr(onError, createError, callback) {
    function handle(e) {
        const error = createError(e);
        onError.emit(error);
        // eslint-disable-next-line no-console
        console.error(error);
        throw error;
    }
    try {
        const result = callback();
        if (isPromise(result)) {
            return result.catch(handle);
        }
        return result;
    }
    catch (e) {
        handle(e);
    }
}
function missingOptionError(option) {
    const options = (Array.isArray(option) ? option : [option]).map((val) => `'${val}'`);
    const lastPart = options.slice(-2).join(' or ');
    const firstPart = options.slice(0, -2);
    const stringifiedOptions = [...firstPart, lastPart].join(', ');
    return `Tolgee: You need to specify ${stringifiedOptions} option`;
}
function isObject(item) {
    return typeof item === 'object' && !Array.isArray(item) && item !== null;
}
function getFallback(value) {
    if (typeof value === 'string') {
        return [value];
    }
    if (Array.isArray(value)) {
        return value;
    }
    return undefined;
}
function getFallbackArray(value) {
    return getFallback(value) || [];
}
function getFallbackFromStruct(language, fallbackLanguage) {
    if (isObject(fallbackLanguage)) {
        return getFallbackArray(fallbackLanguage === null || fallbackLanguage === void 0 ? void 0 : fallbackLanguage[language]);
    }
    else {
        return getFallbackArray(fallbackLanguage);
    }
}
function unique(arr) {
    return Array.from(new Set(arr));
}
function sanitizeUrl(url) {
    return url ? url.replace(/\/+$/, '') : url;
}
function getErrorMessage(error) {
    if (typeof error === 'string') {
        return error;
    }
    else if (typeof (error === null || error === void 0 ? void 0 : error.message) === 'string') {
        return error.message;
    }
}
const defaultFetchFunction = (input, options) => fetch(input, options);
function headersInitToRecord(headersInit) {
    return Object.fromEntries(new Headers(headersInit).entries());
}
const createFetchFunction = (fetchFn = defaultFetchFunction) => {
    return (input, init) => {
        let headers = headersInitToRecord(init === null || init === void 0 ? void 0 : init.headers);
        if (headers['x-api-key']) {
            headers = Object.assign({ 'x-tolgee-sdk-type': 'JS', 'x-tolgee-sdk-version': 'prerelease' }, headers);
        }
        return fetchFn(input, Object.assign(Object.assign({}, init), { headers }));
    };
};

function EventEmitter(isActive) {
    let handlers = [];
    return Object.freeze({
        listen(handler) {
            const handlerWrapper = (e) => {
                handler(e);
            };
            handlers.push(handlerWrapper);
            return {
                unsubscribe() {
                    handlers = handlers.filter((i) => handlerWrapper !== i);
                },
            };
        },
        emit(data) {
            if (isActive()) {
                handlers.forEach((handler) => handler({ value: data }));
            }
        },
    });
}

function EventEmitterSelective(isActive, getFallbackNs, getDefaultNs) {
    const listeners = new Set();
    const partialListeners = new Set();
    function callHandlers(ns) {
        // everything is implicitly subscribed to fallbacks
        // as it can always fall through to it
        const fallbackNamespaces = new Set(getFallbackNs());
        partialListeners.forEach((handler) => {
            const nsMatches = ns === undefined ||
                (ns === null || ns === void 0 ? void 0 : ns.findIndex((ns) => fallbackNamespaces.has(ns) || handler.namespaces.has(ns))) !== -1;
            if (nsMatches) {
                handler.fn({ value: undefined });
            }
        });
    }
    let queue = [];
    // merge events in queue into one event
    function solveQueue() {
        if (queue.length === 0) {
            return;
        }
        const queueCopy = queue;
        queue = [];
        listeners.forEach((handler) => {
            handler({ value: undefined });
        });
        let namespaces = new Set();
        queueCopy.forEach((ns) => {
            if (ns === undefined) {
                // when no ns specified, it affects all namespaces
                namespaces = undefined;
            }
            else if (namespaces !== undefined) {
                ns.forEach((ns) => namespaces.add(ns));
            }
        });
        const namespacesArray = namespaces
            ? Array.from(namespaces.keys())
            : undefined;
        callHandlers(namespacesArray);
    }
    return Object.freeze({
        emit(ns, delayed) {
            if (isActive()) {
                queue.push(ns);
                if (!delayed) {
                    solveQueue();
                }
                else {
                    setTimeout(solveQueue, 0);
                }
            }
        },
        listen(handler) {
            listeners.add(handler);
            const result = {
                unsubscribe: () => {
                    listeners.delete(handler);
                },
            };
            return result;
        },
        listenSome(handler) {
            const handlerWrapper = {
                fn: (e) => {
                    handler(e);
                },
                namespaces: new Set(),
            };
            partialListeners.add(handlerWrapper);
            const result = {
                unsubscribe: () => {
                    partialListeners.delete(handlerWrapper);
                },
                subscribeNs: (ns) => {
                    getFallbackArray(ns).forEach((val) => handlerWrapper.namespaces.add(val));
                    if (ns === undefined) {
                        // subscribing to default ns
                        handlerWrapper.namespaces.add(getDefaultNs());
                    }
                    return result;
                },
            };
            return result;
        },
    });
}

function Events(getFallbackNs, getDefaultNs) {
    let emitterActive = true;
    function isActive() {
        return emitterActive;
    }
    const self = Object.freeze({
        onPendingLanguageChange: EventEmitter(isActive),
        onLanguageChange: EventEmitter(isActive),
        onLoadingChange: EventEmitter(isActive),
        onFetchingChange: EventEmitter(isActive),
        onInitialLoaded: EventEmitter(isActive),
        onRunningChange: EventEmitter(isActive),
        onCacheChange: EventEmitter(isActive),
        onUpdate: EventEmitterSelective(isActive, getFallbackNs, getDefaultNs),
        onPermanentChange: EventEmitter(isActive),
        onError: EventEmitter(isActive),
        setEmitterActive(active) {
            emitterActive = active;
        },
        on: ((event, handler) => {
            switch (event) {
                case 'pendingLanguage':
                    return self.onPendingLanguageChange.listen(handler);
                case 'language':
                    return self.onLanguageChange.listen(handler);
                case 'loading':
                    return self.onLoadingChange.listen(handler);
                case 'fetching':
                    return self.onFetchingChange.listen(handler);
                case 'initialLoad':
                    return self.onInitialLoaded.listen(handler);
                case 'running':
                    return self.onRunningChange.listen(handler);
                case 'cache':
                    return self.onCacheChange.listen(handler);
                case 'update':
                    return self.onUpdate.listen(handler);
                case 'permanentChange':
                    return self.onPermanentChange.listen(handler);
                case 'error':
                    return self.onError.listen(handler);
            }
        }),
    });
    self.onInitialLoaded.listen(() => self.onUpdate.emit());
    self.onLanguageChange.listen(() => self.onUpdate.emit());
    self.onCacheChange.listen(({ value }) => self.onUpdate.emit([value.namespace], true));
    return self;
}

class RecordFetchError extends Error {
    constructor(descriptor, cause, isDev = false) {
        const { language, namespace } = descriptor;
        super(`Tolgee: Failed to fetch record for "${language}"${namespace && ` and "${namespace}"`}`);
        this.cause = cause;
        this.isDev = isDev;
        this.name = 'RecordFetchError';
        this.language = language;
        this.namespace = namespace;
    }
}
class LanguageDetectorError extends Error {
    constructor(message, cause) {
        super(message);
        this.cause = cause;
        this.name = 'LanguageDetectorError';
    }
}
class LanguageStorageError extends Error {
    constructor(message, cause) {
        super(message);
        this.cause = cause;
        this.name = 'LanguageStorageError';
    }
}

const flattenTranslations = (data) => {
    const result = new Map();
    Object.entries(data).forEach(([key, value]) => {
        // ignore empty values
        if (value === undefined || value === null) {
            return;
        }
        if (typeof value === 'object') {
            flattenTranslations(value).forEach((flatValue, flatKey) => {
                result.set(key + '.' + flatKey, flatValue);
            });
            return;
        }
        result.set(key, value);
    });
    return result;
};
const decodeCacheKey = (key) => {
    const [firstPart, ...rest] = key.split(':');
    // if namespaces contains ":" it won't get lost
    const secondPart = rest.join(':');
    return { language: firstPart, namespace: secondPart || '' };
};
const encodeCacheKey = ({ language, namespace, }) => {
    if (namespace) {
        return `${language}:${namespace}`;
    }
    else {
        return language;
    }
};

function Cache(events, backendGetRecord, backendGetDevRecord, withDefaultNs, isInitialLoading, fetchingObserver, loadingObserver) {
    const asyncRequests = new Map();
    const cache = new Map();
    let staticData = {};
    let version = 0;
    function addRecordInternal(descriptor, data, recordVersion) {
        const cacheKey = encodeCacheKey(descriptor);
        cache.set(cacheKey, {
            data: flattenTranslations(data),
            version: recordVersion,
        });
        events.onCacheChange.emit(descriptor);
    }
    /**
     * Fetches production data
     */
    async function fetchProd(keyObject) {
        function handleError(e) {
            const error = new RecordFetchError(keyObject, e);
            events.onError.emit(error);
            // eslint-disable-next-line no-console
            console.error(error);
            throw error;
        }
        const dataFromBackend = backendGetRecord(keyObject);
        if (isPromise(dataFromBackend)) {
            const result = await dataFromBackend.catch(handleError);
            if (result !== undefined) {
                return result;
            }
        }
        const staticDataValue = staticData[encodeCacheKey(keyObject)];
        if (typeof staticDataValue === 'function') {
            try {
                return await staticDataValue();
            }
            catch (e) {
                handleError(e);
            }
        }
        else {
            return staticDataValue;
        }
    }
    async function fetchData(keyObject, isDev) {
        let result = undefined;
        if (isDev) {
            try {
                result = await backendGetDevRecord(keyObject);
            }
            catch (e) {
                const error = new RecordFetchError(keyObject, e, true);
                events.onError.emit(error);
                // eslint-disable-next-line no-console
                console.warn(error);
            }
        }
        if (!result) {
            result = await fetchProd(keyObject);
        }
        return result;
    }
    const self = Object.freeze({
        addStaticData(data) {
            if (data) {
                staticData = Object.assign(Object.assign({}, staticData), data);
                Object.entries(data).forEach(([key, value]) => {
                    if (typeof value !== 'function') {
                        const descriptor = decodeCacheKey(key);
                        const existing = cache.get(key);
                        if (!existing || existing.version === 0) {
                            addRecordInternal(descriptor, value, 0);
                        }
                    }
                });
            }
        },
        invalidate() {
            asyncRequests.clear();
            version += 1;
        },
        addRecord(descriptor, data) {
            addRecordInternal(descriptor, data, version);
        },
        exists(descriptor, strict = false) {
            const record = cache.get(encodeCacheKey(descriptor));
            if (record && strict) {
                return record.version === version;
            }
            return Boolean(record);
        },
        getRecord(descriptor) {
            var _a;
            return (_a = cache.get(encodeCacheKey(withDefaultNs(descriptor)))) === null || _a === void 0 ? void 0 : _a.data;
        },
        getTranslation(descriptor, key) {
            var _a;
            return (_a = cache.get(encodeCacheKey(descriptor))) === null || _a === void 0 ? void 0 : _a.data.get(key);
        },
        getTranslationNs(namespaces, languages, key) {
            var _a;
            for (const namespace of namespaces) {
                for (const language of languages) {
                    const value = (_a = cache
                        .get(encodeCacheKey({ language, namespace }))) === null || _a === void 0 ? void 0 : _a.data.get(key);
                    if (value !== undefined && value !== null) {
                        return [namespace];
                    }
                }
            }
            return unique(namespaces);
        },
        getTranslationFallback(namespaces, languages, key) {
            var _a;
            for (const namespace of namespaces) {
                for (const language of languages) {
                    const value = (_a = cache
                        .get(encodeCacheKey({ language, namespace }))) === null || _a === void 0 ? void 0 : _a.data.get(key);
                    if (value !== undefined && value !== null) {
                        return value;
                    }
                }
            }
            return undefined;
        },
        changeTranslation(descriptor, key, value) {
            var _a;
            const record = (_a = cache.get(encodeCacheKey(descriptor))) === null || _a === void 0 ? void 0 : _a.data;
            record === null || record === void 0 ? void 0 : record.set(key, value);
            events.onCacheChange.emit(Object.assign(Object.assign({}, descriptor), { key }));
        },
        isFetching(ns) {
            if (isInitialLoading()) {
                return true;
            }
            if (ns === undefined) {
                return asyncRequests.size > 0;
            }
            const namespaces = getFallbackArray(ns);
            return Boolean(Array.from(asyncRequests.keys()).find((key) => namespaces.includes(decodeCacheKey(key).namespace)));
        },
        isLoading(language, ns) {
            const namespaces = getFallbackArray(ns);
            return Boolean(isInitialLoading() ||
                Array.from(asyncRequests.keys()).find((key) => {
                    const descriptor = decodeCacheKey(key);
                    return ((!namespaces.length ||
                        namespaces.includes(descriptor.namespace)) &&
                        !self.exists({
                            namespace: descriptor.namespace,
                            language: language,
                        }));
                }));
        },
        async loadRecords(descriptors, isDev) {
            const withPromises = descriptors.map((descriptor) => {
                const keyObject = withDefaultNs(descriptor);
                const cacheKey = encodeCacheKey(keyObject);
                const existingPromise = asyncRequests.get(cacheKey);
                if (existingPromise) {
                    return {
                        new: false,
                        promise: existingPromise,
                        keyObject,
                        cacheKey,
                    };
                }
                const dataPromise = fetchData(keyObject, isDev) || Promise.resolve(undefined);
                asyncRequests.set(cacheKey, dataPromise);
                return {
                    new: true,
                    promise: dataPromise,
                    keyObject,
                    cacheKey,
                };
            });
            fetchingObserver.notify();
            loadingObserver.notify();
            const results = await Promise.all(withPromises.map((val) => val.promise));
            withPromises.forEach((value, i) => {
                const promiseChanged = asyncRequests.get(value.cacheKey) !== value.promise;
                // if promise has changed in between, it means cache been invalidated or
                // new data are being fetched
                if (value.new && !promiseChanged) {
                    asyncRequests.delete(value.cacheKey);
                    const data = results[i];
                    if (data) {
                        self.addRecord(value.keyObject, data);
                    }
                    else if (!self.getRecord(value.keyObject)) {
                        // if no data exist, put empty object
                        self.addRecord(value.keyObject, {});
                    }
                }
            });
            fetchingObserver.notify();
            loadingObserver.notify();
            return withPromises.map((val) => self.getRecord(val.keyObject));
        },
        getAllRecords() {
            const entries = Array.from(cache.entries());
            return entries.map(([key, entry]) => {
                return Object.assign(Object.assign({}, decodeCacheKey(key)), { data: entry.data });
            });
        },
    });
    return self;
}

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

const defaultObserverOptions = {
    tagAttributes: {
        textarea: ['placeholder'],
        input: ['value', 'placeholder'],
        img: ['alt'],
        '*': ['aria-label', 'title'],
    },
    restrictedElements: ['script', 'style'],
    highlightKeys: ['Alt'],
    highlightColor: 'rgb(255, 0, 0)',
    highlightWidth: 5,
    inputPrefix: '%-%tolgee:',
    inputSuffix: '%-%',
    passToParent: ['option', 'optgroup'],
    fullKeyEncode: false,
};

const DEFAULT_FORMAT_ERROR = 'invalid';
const DEFAULT_API_URL = 'https://app.tolgee.io';
const DEFAULT_MISSING_TRANSLATION = ({ key, }) => key;
const defaultValues = {
    defaultNs: '',
    observerOptions: defaultObserverOptions,
    observerType: 'invisible',
    onFormatError: DEFAULT_FORMAT_ERROR,
    apiUrl: DEFAULT_API_URL,
    fetch: createFetchFunction(),
    onTranslationMissing: DEFAULT_MISSING_TRANSLATION,
};
const combineOptions = (...states) => {
    let result = {};
    states.forEach((state) => {
        result = Object.assign(Object.assign(Object.assign({}, result), state), { observerOptions: Object.assign(Object.assign({}, result.observerOptions), state === null || state === void 0 ? void 0 : state.observerOptions) });
    });
    return result;
};
function initState(options, previousState) {
    const initialOptions = combineOptions(defaultValues, previousState === null || previousState === void 0 ? void 0 : previousState.initialOptions, options);
    // remove extra '/' from url end
    initialOptions.apiUrl = sanitizeUrl(initialOptions.apiUrl);
    if (options === null || options === void 0 ? void 0 : options.fetch) {
        initialOptions.fetch = createFetchFunction(options.fetch);
    }
    return {
        initialOptions,
        activeNamespaces: (previousState === null || previousState === void 0 ? void 0 : previousState.activeNamespaces) || new Map(),
        language: previousState === null || previousState === void 0 ? void 0 : previousState.language,
        pendingLanguage: previousState === null || previousState === void 0 ? void 0 : previousState.language,
        isInitialLoading: false,
        isRunning: false,
    };
}

function Plugins(getLanguage, getInitialOptions, getAvailableLanguages, getFallbackNamespaces, getTranslationNs, getTranslation, changeTranslation, events) {
    const plugins = {
        ui: undefined,
    };
    const instances = {
        formatters: [],
        finalFormatter: undefined,
        observer: undefined,
        devBackend: undefined,
        backends: [],
        ui: undefined,
        languageDetector: undefined,
        languageStorage: undefined,
    };
    const onClick = async ({ keysAndDefaults, target }) => {
        var _a;
        const withNs = keysAndDefaults.map(({ key, ns, defaultValue }) => {
            return {
                key,
                defaultValue,
                fallbackNamespaces: getFallbackNamespaces(ns),
                namespace: getTranslationNs({ key, ns })[0],
                translation: getTranslation({
                    key,
                    ns,
                }),
            };
        });
        (_a = instances.ui) === null || _a === void 0 ? void 0 : _a.handleElementClick(withNs, target);
    };
    const findPositions = (key, ns) => {
        var _a;
        return ((_a = instances.observer) === null || _a === void 0 ? void 0 : _a.findPositions(key, ns)) || [];
    };
    function translate(props) {
        const translation = getTranslation({
            key: props.key,
            ns: props.ns,
        });
        return self.formatTranslation(Object.assign(Object.assign({}, props), { translation, formatEnabled: true }));
    }
    function getCommonProps() {
        return { fetch: getInitialOptions().fetch };
    }
    function setObserver(observer) {
        instances.observer = observer === null || observer === void 0 ? void 0 : observer();
    }
    function hasObserver() {
        return Boolean(instances.observer);
    }
    function addFormatter(formatter) {
        if (formatter) {
            instances.formatters.push(formatter);
        }
    }
    function setFinalFormatter(formatter) {
        instances.finalFormatter = formatter;
    }
    function setUi(ui) {
        plugins.ui = ui;
    }
    function hasUi() {
        return Boolean(plugins.ui);
    }
    function setLanguageStorage(storage) {
        instances.languageStorage = storage;
    }
    function setLanguageDetector(detector) {
        instances.languageDetector = detector;
    }
    function storageLoadLanguage() {
        return handleRegularOrAsyncErr(events.onError, (e) => new LanguageStorageError('Tolgee: Failed to load language', e), () => { var _a; return (_a = instances.languageStorage) === null || _a === void 0 ? void 0 : _a.getLanguage(getCommonProps()); });
    }
    function detectLanguage() {
        if (!instances.languageDetector) {
            return undefined;
        }
        const availableLanguages = getAvailableLanguages();
        return handleRegularOrAsyncErr(events.onError, (e) => new LanguageDetectorError('Tolgee: Failed to detect language', e), () => {
            var _a;
            return (_a = instances.languageDetector) === null || _a === void 0 ? void 0 : _a.getLanguage(Object.assign({ availableLanguages }, getCommonProps()));
        });
    }
    function addBackend(backend) {
        if (backend) {
            instances.backends.push(backend);
        }
    }
    function setDevBackend(backend) {
        instances.devBackend = backend;
    }
    function addPlugin(tolgeeInstance, plugin) {
        const pluginTools = Object.freeze({
            setFinalFormatter,
            addFormatter,
            setObserver,
            hasObserver,
            setUi,
            hasUi,
            setDevBackend,
            addBackend,
            setLanguageDetector,
            setLanguageStorage,
        });
        plugin(tolgeeInstance, pluginTools);
    }
    const self = Object.freeze({
        addPlugin,
        findPositions: findPositions,
        run() {
            var _a, _b;
            const { apiKey, apiUrl, projectId, observerOptions, tagNewKeys, filterTag, } = getInitialOptions();
            instances.ui = (_a = plugins.ui) === null || _a === void 0 ? void 0 : _a.call(plugins, {
                apiKey: apiKey,
                apiUrl: apiUrl,
                projectId,
                highlight: self.highlight,
                changeTranslation,
                findPositions,
                onPermanentChange: (data) => events.onPermanentChange.emit(data),
                tagNewKeys,
                filterTag,
            });
            (_b = instances.observer) === null || _b === void 0 ? void 0 : _b.run({
                mouseHighlight: true,
                options: observerOptions,
                translate,
                onClick,
            });
        },
        stop() {
            var _a;
            instances.ui = undefined;
            (_a = instances.observer) === null || _a === void 0 ? void 0 : _a.stop();
        },
        getLanguageStorage() {
            return instances.languageStorage;
        },
        getInitialLanguage() {
            const availableLanguages = getAvailableLanguages();
            const languageOrPromise = storageLoadLanguage();
            return valueOrPromise(languageOrPromise, (language) => {
                if ((!availableLanguages || availableLanguages.includes(language)) &&
                    language) {
                    return language;
                }
                return detectLanguage();
            });
        },
        setStoredLanguage(language) {
            return handleRegularOrAsyncErr(events.onError, (e) => new LanguageStorageError('Tolgee: Failed to store language', e), () => { var _a; return (_a = instances.languageStorage) === null || _a === void 0 ? void 0 : _a.setLanguage(language, getCommonProps()); });
        },
        getDevBackend() {
            return instances.devBackend;
        },
        getBackendRecord: (async ({ language, namespace }) => {
            for (const backend of instances.backends) {
                const data = await backend.getRecord(Object.assign({ language,
                    namespace }, getCommonProps()));
                if (data !== undefined) {
                    return data;
                }
            }
            return undefined;
        }),
        getBackendDevRecord: (async ({ language, namespace }) => {
            var _a;
            const { apiKey, apiUrl, projectId, filterTag } = getInitialOptions();
            return (_a = instances.devBackend) === null || _a === void 0 ? void 0 : _a.getRecord(Object.assign({ apiKey,
                apiUrl,
                projectId,
                language,
                namespace,
                filterTag }, getCommonProps()));
        }),
        getLanguageDetector() {
            return instances.languageDetector;
        },
        retranslate() {
            var _a;
            (_a = instances.observer) === null || _a === void 0 ? void 0 : _a.retranslate();
        },
        highlight: ((key, ns) => {
            var _a, _b;
            return ((_b = (_a = instances.observer) === null || _a === void 0 ? void 0 : _a.highlight) === null || _b === void 0 ? void 0 : _b.call(_a, key, ns)) || { unhighlight() { } };
        }),
        unwrap(text) {
            var _a;
            if (instances.observer) {
                return (_a = instances.observer) === null || _a === void 0 ? void 0 : _a.unwrap(text);
            }
            return { text, keys: [] };
        },
        wrap(params) {
            var _a;
            if (instances.observer) {
                return (_a = instances.observer) === null || _a === void 0 ? void 0 : _a.wrap(params);
            }
            return params.translation;
        },
        hasDevBackend() {
            return Boolean(self.getDevBackend());
        },
        formatTranslation(_a) {
            var _b;
            var { formatEnabled } = _a, props = __rest(_a, ["formatEnabled"]);
            const { key, translation, defaultValue, noWrap, params, ns, orEmpty } = props;
            const formattableTranslation = translation !== null && translation !== void 0 ? translation : defaultValue;
            let translationMissingResult = '';
            if (translation === undefined || translation === null) {
                // called when translation is missing
                // return value is used when 'defaultValue' and 'orEmpty' are not defined
                translationMissingResult =
                    getInitialOptions().onTranslationMissing(props);
            }
            let result = formattableTranslation !== null && formattableTranslation !== void 0 ? formattableTranslation : (orEmpty ? '' : translationMissingResult);
            const language = getLanguage();
            const isFormatEnabled = formatEnabled || !((_b = instances.observer) === null || _b === void 0 ? void 0 : _b.outputNotFormattable);
            const wrap = (result) => {
                if (instances.observer && !noWrap) {
                    return instances.observer.wrap({
                        key,
                        translation: result,
                        defaultValue,
                        params,
                        ns,
                    });
                }
                return result;
            };
            result = wrap(result);
            try {
                if (formattableTranslation && language && isFormatEnabled) {
                    for (const formatter of instances.formatters) {
                        result = formatter.format({
                            translation: result,
                            language,
                            params,
                        });
                    }
                }
                if (instances.finalFormatter &&
                    formattableTranslation &&
                    language &&
                    isFormatEnabled) {
                    result = instances.finalFormatter.format({
                        translation: result,
                        language,
                        params,
                    });
                }
            }
            catch (e) {
                // eslint-disable-next-line no-console
                console.error(e);
                const errorMessage = getErrorMessage(e) || DEFAULT_FORMAT_ERROR;
                const onFormatError = getInitialOptions().onFormatError;
                const formatErrorType = typeof onFormatError;
                if (formatErrorType === 'string') {
                    result = onFormatError;
                }
                else if (formatErrorType === 'function') {
                    result = onFormatError(errorMessage, props);
                }
                else {
                    result = DEFAULT_FORMAT_ERROR;
                }
                // wrap error message, so it's detectable
                result = wrap(result);
            }
            return result;
        },
    });
    return self;
}

const ValueObserver = (initialValue, valueGetter, handler) => {
    let previousValue = initialValue;
    return Object.freeze({
        init(value) {
            previousValue = value;
        },
        notify() {
            const value = valueGetter();
            if (previousValue !== value) {
                handler(value);
            }
            previousValue = value;
        },
    });
};

function State(onLanguageChange, onPendingLanguageChange, onRunningChange) {
    let state = initState();
    let devCredentials = undefined;
    const self = Object.freeze({
        init(options) {
            state = initState(options, state);
        },
        isRunning() {
            return state.isRunning;
        },
        setRunning(value) {
            if (state.isRunning !== value) {
                state.isRunning = value;
                onRunningChange.emit(value);
            }
        },
        isInitialLoading() {
            return state.isInitialLoading;
        },
        setInitialLoading(value) {
            state.isInitialLoading = value;
        },
        getLanguage() {
            return state.language || state.initialOptions.language;
        },
        setLanguage(language) {
            if (state.language !== language) {
                state.language = language;
                onLanguageChange.emit(language);
            }
        },
        getPendingLanguage() {
            return state.pendingLanguage || self.getLanguage();
        },
        setPendingLanguage(language) {
            if (state.pendingLanguage !== language) {
                state.pendingLanguage = language;
                onPendingLanguageChange.emit(language);
            }
        },
        getInitialOptions() {
            return Object.assign(Object.assign({}, state.initialOptions), devCredentials);
        },
        addActiveNs(ns) {
            const namespaces = getFallbackArray(ns);
            namespaces.forEach((namespace) => {
                const value = state.activeNamespaces.get(namespace);
                if (value !== undefined) {
                    state.activeNamespaces.set(namespace, value + 1);
                }
                else {
                    state.activeNamespaces.set(namespace, 1);
                }
            });
        },
        removeActiveNs(ns) {
            const namespaces = getFallbackArray(ns);
            namespaces.forEach((namespace) => {
                const value = state.activeNamespaces.get(namespace);
                if (value !== undefined && value > 1) {
                    state.activeNamespaces.set(namespace, value - 1);
                }
                else {
                    state.activeNamespaces.delete(namespace);
                }
            });
        },
        getRequiredNamespaces() {
            return unique([
                ...(state.initialOptions.ns || [state.initialOptions.defaultNs]),
                ...getFallbackArray(state.initialOptions.fallbackNs),
                ...state.activeNamespaces.keys(),
            ]);
        },
        getFallbackLangs(lang) {
            const language = lang || self.getLanguage();
            if (!language) {
                return [];
            }
            return unique([
                language,
                ...getFallbackFromStruct(language, state.initialOptions.fallbackLanguage),
            ]);
        },
        getFallbackNs() {
            return getFallbackArray(state.initialOptions.fallbackNs);
        },
        getDefaultNs(ns) {
            return ns === undefined ? state.initialOptions.defaultNs : ns;
        },
        getAvailableLanguages() {
            if (state.initialOptions.availableLanguages) {
                return state.initialOptions.availableLanguages;
            }
            else if (state.initialOptions.staticData) {
                const languagesFromStaticData = Object.keys(state.initialOptions.staticData).map((key) => decodeCacheKey(key).language);
                return Array.from(new Set(languagesFromStaticData));
            }
        },
        withDefaultNs(descriptor) {
            return {
                namespace: descriptor.namespace === undefined
                    ? self.getInitialOptions().defaultNs
                    : descriptor.namespace,
                language: descriptor.language,
            };
        },
        overrideCredentials(credentials) {
            if (credentials) {
                devCredentials = Object.assign(Object.assign({}, credentials), { apiUrl: sanitizeUrl(credentials.apiUrl) });
            }
            else {
                devCredentials = undefined;
            }
        },
    });
    return self;
}

function parseCombinedOptions(_a) {
    var { ns, noWrap, orEmpty, params, language } = _a, rest = __rest(_a, ["ns", "noWrap", "orEmpty", "params", "language"]);
    const options = {
        ns: ns,
        noWrap: noWrap,
        orEmpty: orEmpty,
        language: language,
    };
    return Object.assign(Object.assign({}, options), { params: Object.assign({}, rest) });
}
const getTranslateProps = (keyOrProps, ...params) => {
    let result = {};
    let options;
    if (typeof keyOrProps === 'object') {
        result = keyOrProps;
    }
    else {
        result.key = keyOrProps;
        if (typeof params[0] === 'string') {
            result.defaultValue = params[0];
            options = params[1];
        }
        else if (typeof params[0] === 'object') {
            options = params[0];
        }
    }
    if (options) {
        result = Object.assign(Object.assign({}, parseCombinedOptions(options)), result);
    }
    return result;
};

function Controller({ options }) {
    const events = Events(getFallbackNs, getDefaultNs);
    const fetchingObserver = ValueObserver(false, () => cache.isFetching(), events.onFetchingChange.emit);
    const loadingObserver = ValueObserver(false, () => self.isLoading(), events.onLoadingChange.emit);
    const state = State(events.onLanguageChange, events.onPendingLanguageChange, events.onRunningChange);
    const pluginService = Plugins(state.getLanguage, state.getInitialOptions, state.getAvailableLanguages, getDefaultAndFallbackNs, getTranslationNs, getTranslation, changeTranslation, events);
    const cache = Cache(events, pluginService.getBackendRecord, pluginService.getBackendDevRecord, state.withDefaultNs, state.isInitialLoading, fetchingObserver, loadingObserver);
    if (options) {
        init(options);
    }
    let runPromise;
    events.onUpdate.listen(() => {
        if (state.isRunning()) {
            pluginService.retranslate();
        }
    });
    function getFallbackNs() {
        return state.getFallbackNs();
    }
    function getDefaultNs(ns) {
        return state.getDefaultNs(ns);
    }
    // gets all namespaces where translation could be located
    // takes (ns|default, fallback ns)
    function getDefaultAndFallbackNs(ns) {
        return [...getFallbackArray(getDefaultNs(ns)), ...getFallbackNs()];
    }
    // gets all namespaces which need to be loaded
    // takes (ns|default, initial ns, fallback ns, active ns)
    function getRequiredNamespaces(ns) {
        return [
            ...getFallbackArray(ns !== null && ns !== void 0 ? ns : getDefaultNs()),
            ...state.getRequiredNamespaces(),
        ];
    }
    function changeTranslation(descriptor, key, value) {
        const keyObject = state.withDefaultNs(descriptor);
        const previousValue = cache.getTranslation(keyObject, key);
        cache.changeTranslation(keyObject, key, value);
        return {
            revert() {
                cache.changeTranslation(keyObject, key, previousValue);
            },
        };
    }
    function init(options) {
        state.init(options);
        cache.addStaticData(state.getInitialOptions().staticData);
    }
    function getRequiredRecords(lang, ns) {
        const languages = state.getFallbackLangs(lang);
        const namespaces = getRequiredNamespaces(ns);
        const result = [];
        languages.forEach((language) => {
            namespaces.forEach((namespace) => {
                if (!cache.exists({ language, namespace }, true)) {
                    result.push({ language, namespace });
                }
            });
        });
        return result;
    }
    function loadRequiredRecords(lang, ns) {
        const descriptors = getRequiredRecords(lang, ns);
        if (descriptors.length) {
            return valueOrPromise(self.loadRecords(descriptors), () => { });
        }
    }
    function getTranslationNs({ key, ns }) {
        const languages = state.getFallbackLangs();
        const namespaces = getDefaultAndFallbackNs(ns !== null && ns !== void 0 ? ns : undefined);
        return cache.getTranslationNs(namespaces, languages, key);
    }
    function getTranslation({ key, ns, language }) {
        const namespaces = getDefaultAndFallbackNs(ns !== null && ns !== void 0 ? ns : undefined);
        const languages = state.getFallbackLangs(language);
        return cache.getTranslationFallback(namespaces, languages, key);
    }
    function loadInitial() {
        const data = valueOrPromise(initializeLanguage(), () => {
            // fail if there is no language
            return loadRequiredRecords();
        });
        if (isPromise(data)) {
            state.setInitialLoading(true);
            fetchingObserver.notify();
            loadingObserver.notify();
            return Promise.resolve(data).then(() => {
                state.setInitialLoading(false);
                fetchingObserver.notify();
                loadingObserver.notify();
                events.onInitialLoaded.emit();
            });
        }
        else {
            events.onInitialLoaded.emit();
        }
    }
    function initializeLanguage() {
        const existingLanguage = state.getLanguage();
        if (existingLanguage) {
            return;
        }
        const languageOrPromise = pluginService.getInitialLanguage();
        return valueOrPromise(languageOrPromise, (lang) => {
            const language = lang ||
                state.getInitialOptions().defaultLanguage;
            language && state.setLanguage(language);
        });
    }
    function checkCorrectConfiguration() {
        const languageComputable = pluginService.getLanguageDetector() || pluginService.getLanguageStorage();
        if (languageComputable) {
            const availableLanguages = state.getAvailableLanguages();
            if (!availableLanguages) {
                throw new Error(missingOptionError('availableLanguages'));
            }
        }
        if (!state.getLanguage() && !state.getInitialOptions().defaultLanguage) {
            throw new Error(missingOptionError(['defaultLanguage', 'language']));
        }
    }
    const self = Object.freeze(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, events), state), pluginService), cache), { init: init, getTranslation: getTranslation, changeTranslation: changeTranslation, getTranslationNs: getTranslationNs, getDefaultAndFallbackNs: getDefaultAndFallbackNs, findPositions: pluginService.findPositions, getRequiredRecords: getRequiredRecords, async changeLanguage(language) {
            if (state.getPendingLanguage() === language &&
                state.getLanguage() === language) {
                return;
            }
            state.setPendingLanguage(language);
            if (state.isRunning()) {
                await loadRequiredRecords(language);
            }
            if (language === state.getPendingLanguage()) {
                // there might be parallel language change
                // we only want to apply latest
                state.setLanguage(language);
                await pluginService.setStoredLanguage(language);
            }
        },
        async addActiveNs(ns, forget) {
            if (!forget) {
                state.addActiveNs(ns);
            }
            if (state.isRunning()) {
                await loadRequiredRecords(undefined, ns);
            }
        },
        loadRecords(descriptors) {
            return cache.loadRecords(descriptors, self.isDev());
        },
        async loadRecord(descriptor) {
            return (await self.loadRecords([descriptor]))[0];
        },
        isLoading(ns) {
            return cache.isLoading(state.getLanguage(), ns);
        },
        isLoaded(ns) {
            const language = state.getLanguage();
            if (!language) {
                return false;
            }
            const languages = state.getFallbackLangs(language);
            const namespaces = getRequiredNamespaces(ns);
            const result = [];
            languages.forEach((language) => {
                namespaces.forEach((namespace) => {
                    if (!cache.exists({ language, namespace })) {
                        result.push({ language, namespace });
                    }
                });
            });
            return result.length === 0;
        }, t: ((...args) => {
            // @ts-ignore
            const params = getTranslateProps(...args);
            const translation = getTranslation(params);
            return pluginService.formatTranslation(Object.assign(Object.assign({}, params), { translation }));
        }), isDev() {
            return Boolean(state.getInitialOptions().apiKey && state.getInitialOptions().apiUrl);
        },
        run() {
            checkCorrectConfiguration();
            if (!state.isRunning()) {
                state.setRunning(true);
                pluginService.run();
                runPromise = loadInitial();
            }
            return Promise.resolve(runPromise);
        },
        stop() {
            if (state.isRunning()) {
                pluginService.stop();
                state.setRunning(false);
            }
        } }));
    return self;
}

function createTolgee(options) {
    const controller = Controller({
        options,
    });
    if (controller.isDev()) {
        // override existing data in DevMode
        controller.invalidate();
    }
    // restarts tolgee while applying callback
    function withRestart(callback) {
        const wasRunning = controller.isRunning();
        wasRunning && controller.stop();
        callback();
        // invalidate cache when tolgee configuration is updated/plugin added in DevMode
        controller.isDev() && controller.invalidate();
        wasRunning && controller.run();
    }
    const self = Object.freeze({
        /**
         * Listen to tolgee events.
         */
        on: controller.on,
        /**
         * Listen for specific namespaces changes.
         *
         * ```
         * const sub = tolgee.onUpdate(handler)
         *
         * // subscribe to selected namespace
         * sub.subscribeNs(['common'])
         *
         * // unsubscribe
         * sub.unsubscribe()
         * ```
         */
        onNsUpdate: controller.onUpdate.listenSome,
        /**
         * Turn off/on events emitting. Is on by default.
         */
        setEmitterActive: controller.setEmitterActive,
        /**
         * @return current language if set.
         */
        getLanguage: controller.getLanguage,
        /**
         * `pendingLanguage` represents language which is currently being loaded.
         * @return current `pendingLanguage` if set.
         */
        getPendingLanguage: controller.getPendingLanguage,
        /**
         * Change current language.
         * - if not running sets `pendingLanguage`, `language` to the new value
         * - if running sets `pendingLanguage` to the value, fetches necessary data and then changes `language`
         *
         * @return Promise which is resolved when `language` is changed.
         */
        changeLanguage: controller.changeLanguage,
        /**
         * Temporarily change translation in cache.
         * @return object with revert method.
         */
        changeTranslation: controller.changeTranslation,
        /**
         * Adds namespace(s) list of active namespaces. And if tolgee is running, loads required data.
         */
        addActiveNs: controller.addActiveNs,
        /**
         * Remove namespace(s) from active namespaces.
         *
         * Tolgee internally counts how many times was each active namespace added,
         * so this method will remove namespace only if the counter goes down to 0.
         */
        removeActiveNs: controller.removeActiveNs,
        /**
         * Manually load multiple records from `Backend` (or `DevBackend` when in dev mode)
         *
         * It loads data together and adds them to cache in one operation, to prevent partly loaded state.
         */
        loadRecords: controller.loadRecords,
        /**
         * Manually load record from `Backend` (or `DevBackend` when in dev mode)
         */
        loadRecord: controller.loadRecord,
        /**
         * Prefill static data
         */
        addStaticData: controller.addStaticData,
        /**
         * Get record from cache.
         */
        getRecord: controller.getRecord,
        /**
         * Get all records from cache.
         */
        getAllRecords: controller.getAllRecords,
        /**
         * @param ns optional list of namespaces that you are interested in
         * @return `true` if there are data that need to be fetched.
         */
        isLoaded: controller.isLoaded,
        /**
         * Returns records needed for instance to be `loaded`
         */
        getRequiredRecords: controller.getRequiredRecords,
        /**
         * @return `true` if tolgee is loading initial data (triggered by `run`).
         */
        isInitialLoading: controller.isInitialLoading,
        /**
         * @param ns optional list of namespaces that you are interested in
         * @return `true` if tolgee is loading some translations for the first time.
         */
        isLoading: controller.isLoading,
        /**
         * @param ns optional list of namespaces that you are interested in
         * @return `true` if tolgee is fetching some translations.
         */
        isFetching: controller.isFetching,
        /**
         * @return `true` if tolgee is running.
         */
        isRunning: controller.isRunning,
        /**
         * Changes internal state to running: true and loads initial files.
         * Runs runnable plugins mainly Observer if present.
         */
        run: controller.run,
        /**
         * Changes internal state to running: false and stops runnable plugins.
         */
        stop: controller.stop,
        /**
         * Returns translated and formatted key.
         * If Observer is present and tolgee is running, wraps result to be identifiable in the DOM.
         */
        t: controller.t,
        /**
         * Highlight keys that match selection.
         */
        highlight: controller.highlight,
        /**
         * Find positions of keys in the DOM.
         */
        findPositions: controller.findPositions,
        /**
         * @return current Tolgee options.
         */
        getInitialOptions: controller.getInitialOptions,
        /**
         * Tolgee is in dev mode if `DevTools` plugin is used and `apiKey` + `apiUrl` are specified.
         * @return `true` if tolgee is in dev mode.
         */
        isDev: controller.isDev,
        /**
         * Wraps translation if there is `Observer` plugin
         */
        wrap: controller.wrap,
        /**
         * Unwrap translation
         */
        unwrap: controller.unwrap,
        /**
         * Override creadentials passed on initialization.
         *
         * When called in running state, tolgee stops and runs again.
         */
        overrideCredentials(credentials) {
            withRestart(() => controller.overrideCredentials(credentials));
        },
        /**
         * Add tolgee plugin after initialization.
         *
         * When called in running state, tolgee stops and runs again.
         */
        addPlugin(plugin) {
            if (plugin) {
                withRestart(() => controller.addPlugin(self, plugin));
            }
        },
        /**
         * Updates options after instance creation. Extends existing options,
         * so it only changes the fields, that are listed.
         *
         * When called in running state, tolgee stops and runs again.
         */
        updateOptions(options) {
            if (options) {
                withRestart(() => controller.init(options));
            }
        },
    });
    return self;
}
/**
 * Tolgee chainable constructor.
 *
 * Usage:
 * ```
 * const tolgee = Tolgee().use(...).init(...)
 * ```
 */
const TolgeeCore = () => {
    const state = {
        plugins: [],
        options: {},
    };
    const tolgeeChain = Object.freeze({
        use(plugin) {
            state.plugins.push(plugin);
            return tolgeeChain;
        },
        updateDefaults(options) {
            state.options = combineOptions(state.options, options);
            return tolgeeChain;
        },
        init(options) {
            const tolgee = createTolgee(combineOptions(state.options, options));
            state.plugins.forEach(tolgee.addPlugin);
            return tolgee;
        },
    });
    return tolgeeChain;
};

const ERROR_PARAM_EMPTY = 0, ERROR_UNEXPECTED_CHAR = 1, ERROR_UNEXPECTED_END = 2;
class FormatError extends Error {
    constructor(code, index, text) {
        let error;
        let hint = '';
        if (code === ERROR_PARAM_EMPTY) {
            error = 'Empty parameter';
        }
        else if (code === ERROR_UNEXPECTED_CHAR) {
            error = 'Unexpected character';
            hint = 'Did you forget to use FormatIcu to render ICU message syntax?';
        }
        else {
            error = 'Unexpected end';
        }
        super(`Tolgee parser: ${error} at ${index} in "${text}"` +
            (hint ? '\n' + hint : ''));
        this.code = code;
        this.index = index;
    }
}

function isWhitespace(ch) {
    return /\s/.test(ch);
}
const STATE_TEXT = 0, STATE_ESCAPE_MAYBE = 1, STATE_ESCAPE = 2, STATE_PARAM = 3, STATE_PARAM_AFTER = 4;
const END_STATES = new Set([
    STATE_ESCAPE,
    STATE_ESCAPE_MAYBE,
    STATE_TEXT,
]);
const CHAR_ESCAPE = "'";
const ESCAPABLE = new Set(['{', '}', CHAR_ESCAPE]);
const isAllowedInParam = (char) => {
    return /[0-9a-zA-Z_]/.test(char);
};
function formatParser(translation) {
    let state = STATE_TEXT;
    let text = '';
    let param = '';
    let ch = '';
    const texts = [];
    const params = [];
    let i = 0;
    function parsingError(code) {
        throw new FormatError(code, i, translation);
    }
    const addText = () => {
        texts.push(text);
        text = '';
    };
    const addParamChar = () => {
        if (!isAllowedInParam(ch)) {
            parsingError(ERROR_UNEXPECTED_CHAR);
        }
        param += ch;
    };
    const addParam = () => {
        if (param === '') {
            parsingError(ERROR_PARAM_EMPTY);
        }
        params.push(param);
        param = '';
    };
    for (i = 0; i < translation.length; i++) {
        ch = translation[i];
        switch (state) {
            case STATE_TEXT:
                if (ch === CHAR_ESCAPE) {
                    text += ch;
                    state = STATE_ESCAPE_MAYBE;
                }
                else if (ch === '{') {
                    addText();
                    state = STATE_PARAM;
                }
                else {
                    text += ch;
                    state = STATE_TEXT;
                }
                break;
            case STATE_ESCAPE_MAYBE:
                if (ESCAPABLE.has(ch)) {
                    text = text.slice(0, -1) + ch;
                    state = STATE_ESCAPE;
                }
                else {
                    text += ch;
                    state = STATE_TEXT;
                }
                break;
            case STATE_ESCAPE:
                if (ch === CHAR_ESCAPE) {
                    state = STATE_TEXT;
                }
                else {
                    text += ch;
                    state = STATE_ESCAPE;
                }
                break;
            case STATE_PARAM:
                if (ch === '}') {
                    addParam();
                    state = STATE_TEXT;
                }
                else if (!isWhitespace(ch)) {
                    addParamChar();
                    state = STATE_PARAM;
                }
                else if (param !== '') {
                    addParam();
                    state = STATE_PARAM_AFTER;
                }
                break;
            case STATE_PARAM_AFTER:
                if (ch == '}') {
                    state = STATE_TEXT;
                }
                else if (isWhitespace(ch)) {
                    state = STATE_PARAM_AFTER;
                }
                else {
                    parsingError(ERROR_UNEXPECTED_CHAR);
                }
        }
    }
    if (!END_STATES.has(state)) {
        parsingError(ERROR_UNEXPECTED_END);
    }
    addText();
    return [texts, params];
}

function formatter(translation, params) {
    const [texts, pars] = formatParser(translation);
    const result = [texts[0]];
    for (let i = 1; i < texts.length; i++) {
        const parameter = params === null || params === void 0 ? void 0 : params[pars[i - 1]];
        if (parameter === undefined) {
            throw new Error(`Missing parameter "${pars[i - 1]}" in "${translation}"`);
        }
        result.push(String(parameter));
        result.push(texts[i]);
    }
    return result.join('');
}

function createFormatSimple() {
    return {
        format: ({ translation, params }) => formatter(translation, params),
    };
}
const FormatSimple = () => (tolgee, tools) => {
    tools.setFinalFormatter(createFormatSimple());
    return tolgee;
};

export { FormatSimple, LanguageDetectorError, LanguageStorageError, RecordFetchError, TolgeeCore, createFetchFunction, getFallback, getFallbackArray, getTranslateProps };
//# sourceMappingURL=tolgee.esm.mjs.map
