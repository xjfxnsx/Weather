import { CacheDescriptor, NsFallback, TolgeeOptions, TFnType, NsType, KeyAndNamespacesInternal } from '../types';
type StateServiceProps = {
    options?: Partial<TolgeeOptions>;
};
export declare function Controller({ options }: StateServiceProps): Readonly<{
    init: (options: Partial<TolgeeOptions>) => void;
    getTranslation: ({ key, ns, language }: KeyAndNamespacesInternal) => string | undefined;
    changeTranslation: (descriptor: CacheDescriptor, key: string, value: string) => {
        revert(): void;
    };
    getTranslationNs: ({ key, ns }: KeyAndNamespacesInternal) => string[];
    getDefaultAndFallbackNs: (ns?: NsType) => string[];
    findPositions: import("../types").FindPositionsInterface;
    getRequiredRecords: (lang?: string, ns?: NsFallback) => CacheDescriptor[];
    changeLanguage(language: string): Promise<void>;
    addActiveNs(ns: NsFallback, forget?: boolean): Promise<void>;
    loadRecords(descriptors: CacheDescriptor[]): Promise<import("../types").TranslationsFlat[]>;
    loadRecord(descriptor: CacheDescriptor): Promise<import("../types").TranslationsFlat>;
    isLoading(ns?: NsFallback): boolean;
    isLoaded(ns?: NsFallback): boolean;
    t: TFnType<import("../types").DefaultParamType, string, import("../types").TranslationKey>;
    isDev(): boolean;
    run(): Promise<any>;
    stop(): void;
    addStaticData: (data: import("./State/initState").TolgeeStaticData | undefined) => void;
    invalidate: () => void;
    addRecord: (descriptor: import("../types").CacheDescriptorInternal, data: import("../types").TreeTranslationsData) => void;
    exists: (descriptor: import("../types").CacheDescriptorInternal, strict?: boolean) => boolean;
    getRecord: (descriptor: CacheDescriptor) => import("../types").TranslationsFlat | undefined;
    getTranslationFallback: (namespaces: string[], languages: string[], key: string) => string | undefined;
    isFetching: (ns?: NsFallback) => boolean;
    getAllRecords: () => {
        data: import("../types").TranslationsFlat;
        language: string;
        namespace: string;
    }[];
    addPlugin: (tolgeeInstance: import("../TolgeeCore").TolgeeInstance, plugin: import("../types").TolgeePlugin) => void;
    getLanguageStorage: () => import("../types").LanguageStorageMiddleware | undefined;
    getInitialLanguage: () => string | Promise<string | undefined> | Promise<string | Promise<string | undefined> | undefined> | undefined;
    setStoredLanguage: (language: string) => void | Promise<void | undefined> | undefined;
    getDevBackend: () => import("../types").BackendDevMiddleware | undefined;
    getBackendRecord: import("../types").BackendGetRecordInternal;
    getBackendDevRecord: import("../types").BackendGetRecordInternal;
    getLanguageDetector: () => import("../types").LanguageDetectorMiddleware | undefined;
    retranslate: () => void;
    highlight: import("../types").HighlightInterface;
    unwrap: (text: string) => import("../types").Unwrapped;
    wrap: (params: import("../types").WrapperWrapProps) => string | undefined;
    hasDevBackend: () => boolean;
    formatTranslation: ({ formatEnabled, ...props }: {
        key: import("../types").TranslationKey;
        defaultValue?: string | undefined;
        params?: import("../types").TranslateParams<import("../types").DefaultParamType> | undefined;
    } & import("../types").TranslateOptions & {
        translation?: string | undefined;
    } & {
        formatEnabled?: boolean | undefined;
    }) => string;
    isRunning: () => boolean;
    setRunning: (value: boolean) => void;
    isInitialLoading: () => boolean;
    setInitialLoading: (value: boolean) => void;
    getLanguage: () => string | undefined;
    setLanguage: (language: string) => void;
    getPendingLanguage: () => string | undefined;
    setPendingLanguage: (language: string) => void;
    getInitialOptions: () => {
        apiUrl?: string | undefined;
        apiKey?: string | undefined;
        projectId?: string | number | undefined;
        language?: string | undefined;
        defaultLanguage?: string | undefined;
        availableLanguages?: string[] | undefined;
        fallbackLanguage?: import("../types").FallbackLanguageOption;
        ns?: string[] | undefined;
        fallbackNs?: import("../types").FallbackGeneral;
        defaultNs: string;
        staticData?: import("./State/initState").TolgeeStaticData | undefined;
        observerType: "invisible" | "text";
        observerOptions: import("./State/observerOptions").ObserverOptionsInternal;
        onFormatError: import("../types").OnFormatError;
        onTranslationMissing: import("../types").MissingTranslationHandler;
        fetch: import("../types").FetchFn;
        tagNewKeys?: string[] | undefined;
        filterTag?: string[] | undefined;
    };
    removeActiveNs: (ns: NsFallback) => void;
    getRequiredNamespaces: () => string[];
    getFallbackLangs: (lang?: string | undefined) => string[];
    getFallbackNs: () => string[];
    getDefaultNs: (ns?: string | undefined) => string;
    getAvailableLanguages: () => string[] | undefined;
    withDefaultNs: (descriptor: CacheDescriptor) => import("../types").CacheDescriptorInternal;
    overrideCredentials: (credentials: import("../types").DevCredentials) => void;
    onPendingLanguageChange: import("./Events/EventEmitter").EventEmitterInstance<string>;
    onLanguageChange: import("./Events/EventEmitter").EventEmitterInstance<string>;
    onLoadingChange: import("./Events/EventEmitter").EventEmitterInstance<boolean>;
    onFetchingChange: import("./Events/EventEmitter").EventEmitterInstance<boolean>;
    onInitialLoaded: import("./Events/EventEmitter").EventEmitterInstance<void>;
    onRunningChange: import("./Events/EventEmitter").EventEmitterInstance<boolean>;
    onCacheChange: import("./Events/EventEmitter").EventEmitterInstance<import("../types").CacheDescriptorWithKey>;
    onUpdate: import("./Events/EventEmitterSelective").EventEmitterSelectiveInstance;
    onPermanentChange: import("./Events/EventEmitter").EventEmitterInstance<import("../types").TranslationDescriptor>;
    onError: import("./Events/EventEmitter").EventEmitterInstance<import("../types").TolgeeError>;
    setEmitterActive: (active: boolean) => void;
    on: import("../types").TolgeeOn<keyof import("../types").EventType>;
}>;
export type ControllerInstance = ReturnType<typeof Controller>;
export {};
